// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v5.27.1
// source: internal/proto/speech.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	UserAccountService_CreateUser_FullMethodName         = "/auth.UserAccountService/CreateUser"
	UserAccountService_GetUserById_FullMethodName        = "/auth.UserAccountService/GetUserById"
	UserAccountService_GetUsersByUsername_FullMethodName = "/auth.UserAccountService/GetUsersByUsername"
	UserAccountService_UpdateUser_FullMethodName         = "/auth.UserAccountService/UpdateUser"
	UserAccountService_DeleteUser_FullMethodName         = "/auth.UserAccountService/DeleteUser"
)

// UserAccountServiceClient is the client API for UserAccountService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// User Account Service
type UserAccountServiceClient interface {
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	GetUserById(ctx context.Context, in *GetUserByIdRequest, opts ...grpc.CallOption) (*User, error)
	GetUsersByUsername(ctx context.Context, in *GetUsersByUsernameRequest, opts ...grpc.CallOption) (*GetUsersByUsernameResponse, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountServiceClient(cc grpc.ClientConnInterface) UserAccountServiceClient {
	return &userAccountServiceClient{cc}
}

func (c *userAccountServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, UserAccountService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userAccountServiceClient) GetUserById(ctx context.Context, in *GetUserByIdRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserAccountService_GetUserById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userAccountServiceClient) GetUsersByUsername(ctx context.Context, in *GetUsersByUsernameRequest, opts ...grpc.CallOption) (*GetUsersByUsernameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsersByUsernameResponse)
	err := c.cc.Invoke(ctx, UserAccountService_GetUsersByUsername_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userAccountServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserAccountService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userAccountServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountServiceServer is the server API for UserAccountService service.
// All implementations must embed UnimplementedUserAccountServiceServer
// for forward compatibility
//
// User Account Service
type UserAccountServiceServer interface {
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	GetUserById(context.Context, *GetUserByIdRequest) (*User, error)
	GetUsersByUsername(context.Context, *GetUsersByUsernameRequest) (*GetUsersByUsernameResponse, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*User, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserAccountServiceServer()
}

// UnimplementedUserAccountServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserAccountServiceServer struct {
}

func (UnimplementedUserAccountServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserAccountServiceServer) GetUserById(context.Context, *GetUserByIdRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserById not implemented")
}
func (UnimplementedUserAccountServiceServer) GetUsersByUsername(context.Context, *GetUsersByUsernameRequest) (*GetUsersByUsernameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsersByUsername not implemented")
}
func (UnimplementedUserAccountServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserAccountServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserAccountServiceServer) mustEmbedUnimplementedUserAccountServiceServer() {}

// UnsafeUserAccountServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountServiceServer will
// result in compilation errors.
type UnsafeUserAccountServiceServer interface {
	mustEmbedUnimplementedUserAccountServiceServer()
}

func RegisterUserAccountServiceServer(s grpc.ServiceRegistrar, srv UserAccountServiceServer) {
	s.RegisterService(&UserAccountService_ServiceDesc, srv)
}

func _UserAccountService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserAccountService_GetUserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountServiceServer).GetUserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountService_GetUserById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountServiceServer).GetUserById(ctx, req.(*GetUserByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserAccountService_GetUsersByUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsersByUsernameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountServiceServer).GetUsersByUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountService_GetUsersByUsername_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountServiceServer).GetUsersByUsername(ctx, req.(*GetUsersByUsernameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserAccountService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserAccountService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountService_ServiceDesc is the grpc.ServiceDesc for UserAccountService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.UserAccountService",
	HandlerType: (*UserAccountServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserAccountService_CreateUser_Handler,
		},
		{
			MethodName: "GetUserById",
			Handler:    _UserAccountService_GetUserById_Handler,
		},
		{
			MethodName: "GetUsersByUsername",
			Handler:    _UserAccountService_GetUsersByUsername_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserAccountService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserAccountService_DeleteUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	AuthenticationService_Login_FullMethodName        = "/auth.AuthenticationService/Login"
	AuthenticationService_Logout_FullMethodName       = "/auth.AuthenticationService/Logout"
	AuthenticationService_RefreshToken_FullMethodName = "/auth.AuthenticationService/RefreshToken"
)

// AuthenticationServiceClient is the client API for AuthenticationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Authentication Service
type AuthenticationServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
}

type authenticationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthenticationServiceClient(cc grpc.ClientConnInterface) AuthenticationServiceClient {
	return &authenticationServiceClient{cc}
}

func (c *authenticationServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AuthenticationService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshTokenResponse)
	err := c.cc.Invoke(ctx, AuthenticationService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthenticationServiceServer is the server API for AuthenticationService service.
// All implementations must embed UnimplementedAuthenticationServiceServer
// for forward compatibility
//
// Authentication Service
type AuthenticationServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error)
	RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
	mustEmbedUnimplementedAuthenticationServiceServer()
}

// UnimplementedAuthenticationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAuthenticationServiceServer struct {
}

func (UnimplementedAuthenticationServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthenticationServiceServer) Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedAuthenticationServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedAuthenticationServiceServer) mustEmbedUnimplementedAuthenticationServiceServer() {}

// UnsafeAuthenticationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthenticationServiceServer will
// result in compilation errors.
type UnsafeAuthenticationServiceServer interface {
	mustEmbedUnimplementedAuthenticationServiceServer()
}

func RegisterAuthenticationServiceServer(s grpc.ServiceRegistrar, srv AuthenticationServiceServer) {
	s.RegisterService(&AuthenticationService_ServiceDesc, srv)
}

func _AuthenticationService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthenticationService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthenticationService_ServiceDesc is the grpc.ServiceDesc for AuthenticationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthenticationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthenticationService",
	HandlerType: (*AuthenticationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _AuthenticationService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _AuthenticationService_Logout_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _AuthenticationService_RefreshToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	EmailService_SendVerificationEmail_FullMethodName = "/auth.EmailService/SendVerificationEmail"
	EmailService_VerifyEmail_FullMethodName           = "/auth.EmailService/VerifyEmail"
)

// EmailServiceClient is the client API for EmailService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Email Service
type EmailServiceClient interface {
	SendVerificationEmail(ctx context.Context, in *SendVerificationEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type emailServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEmailServiceClient(cc grpc.ClientConnInterface) EmailServiceClient {
	return &emailServiceClient{cc}
}

func (c *emailServiceClient) SendVerificationEmail(ctx context.Context, in *SendVerificationEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EmailService_SendVerificationEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emailServiceClient) VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EmailService_VerifyEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmailServiceServer is the server API for EmailService service.
// All implementations must embed UnimplementedEmailServiceServer
// for forward compatibility
//
// Email Service
type EmailServiceServer interface {
	SendVerificationEmail(context.Context, *SendVerificationEmailRequest) (*emptypb.Empty, error)
	VerifyEmail(context.Context, *VerifyEmailRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedEmailServiceServer()
}

// UnimplementedEmailServiceServer must be embedded to have forward compatible implementations.
type UnimplementedEmailServiceServer struct {
}

func (UnimplementedEmailServiceServer) SendVerificationEmail(context.Context, *SendVerificationEmailRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendVerificationEmail not implemented")
}
func (UnimplementedEmailServiceServer) VerifyEmail(context.Context, *VerifyEmailRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyEmail not implemented")
}
func (UnimplementedEmailServiceServer) mustEmbedUnimplementedEmailServiceServer() {}

// UnsafeEmailServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EmailServiceServer will
// result in compilation errors.
type UnsafeEmailServiceServer interface {
	mustEmbedUnimplementedEmailServiceServer()
}

func RegisterEmailServiceServer(s grpc.ServiceRegistrar, srv EmailServiceServer) {
	s.RegisterService(&EmailService_ServiceDesc, srv)
}

func _EmailService_SendVerificationEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendVerificationEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailServiceServer).SendVerificationEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailService_SendVerificationEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailServiceServer).SendVerificationEmail(ctx, req.(*SendVerificationEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmailService_VerifyEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailServiceServer).VerifyEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailService_VerifyEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailServiceServer).VerifyEmail(ctx, req.(*VerifyEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EmailService_ServiceDesc is the grpc.ServiceDesc for EmailService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EmailService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.EmailService",
	HandlerType: (*EmailServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendVerificationEmail",
			Handler:    _EmailService_SendVerificationEmail_Handler,
		},
		{
			MethodName: "VerifyEmail",
			Handler:    _EmailService_VerifyEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	PasswordService_RequestPasswordReset_FullMethodName = "/auth.PasswordService/RequestPasswordReset"
	PasswordService_ResetPassword_FullMethodName        = "/auth.PasswordService/ResetPassword"
)

// PasswordServiceClient is the client API for PasswordService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Password Service
type PasswordServiceClient interface {
	RequestPasswordReset(ctx context.Context, in *RequestPasswordResetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type passwordServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPasswordServiceClient(cc grpc.ClientConnInterface) PasswordServiceClient {
	return &passwordServiceClient{cc}
}

func (c *passwordServiceClient) RequestPasswordReset(ctx context.Context, in *RequestPasswordResetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PasswordService_RequestPasswordReset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passwordServiceClient) ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PasswordService_ResetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PasswordServiceServer is the server API for PasswordService service.
// All implementations must embed UnimplementedPasswordServiceServer
// for forward compatibility
//
// Password Service
type PasswordServiceServer interface {
	RequestPasswordReset(context.Context, *RequestPasswordResetRequest) (*emptypb.Empty, error)
	ResetPassword(context.Context, *ResetPasswordRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedPasswordServiceServer()
}

// UnimplementedPasswordServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPasswordServiceServer struct {
}

func (UnimplementedPasswordServiceServer) RequestPasswordReset(context.Context, *RequestPasswordResetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestPasswordReset not implemented")
}
func (UnimplementedPasswordServiceServer) ResetPassword(context.Context, *ResetPasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedPasswordServiceServer) mustEmbedUnimplementedPasswordServiceServer() {}

// UnsafePasswordServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PasswordServiceServer will
// result in compilation errors.
type UnsafePasswordServiceServer interface {
	mustEmbedUnimplementedPasswordServiceServer()
}

func RegisterPasswordServiceServer(s grpc.ServiceRegistrar, srv PasswordServiceServer) {
	s.RegisterService(&PasswordService_ServiceDesc, srv)
}

func _PasswordService_RequestPasswordReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestPasswordResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasswordServiceServer).RequestPasswordReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasswordService_RequestPasswordReset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasswordServiceServer).RequestPasswordReset(ctx, req.(*RequestPasswordResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PasswordService_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasswordServiceServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasswordService_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasswordServiceServer).ResetPassword(ctx, req.(*ResetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PasswordService_ServiceDesc is the grpc.ServiceDesc for PasswordService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PasswordService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.PasswordService",
	HandlerType: (*PasswordServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestPasswordReset",
			Handler:    _PasswordService_RequestPasswordReset_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _PasswordService_ResetPassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	SessionManagementService_GetUserSessions_FullMethodName = "/auth.SessionManagementService/GetUserSessions"
	SessionManagementService_DeleteSession_FullMethodName   = "/auth.SessionManagementService/DeleteSession"
)

// SessionManagementServiceClient is the client API for SessionManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Session Management Service
type SessionManagementServiceClient interface {
	GetUserSessions(ctx context.Context, in *GetUserSessionsRequest, opts ...grpc.CallOption) (*GetUserSessionsResponse, error)
	DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sessionManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionManagementServiceClient(cc grpc.ClientConnInterface) SessionManagementServiceClient {
	return &sessionManagementServiceClient{cc}
}

func (c *sessionManagementServiceClient) GetUserSessions(ctx context.Context, in *GetUserSessionsRequest, opts ...grpc.CallOption) (*GetUserSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserSessionsResponse)
	err := c.cc.Invoke(ctx, SessionManagementService_GetUserSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionManagementServiceClient) DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionManagementService_DeleteSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionManagementServiceServer is the server API for SessionManagementService service.
// All implementations must embed UnimplementedSessionManagementServiceServer
// for forward compatibility
//
// Session Management Service
type SessionManagementServiceServer interface {
	GetUserSessions(context.Context, *GetUserSessionsRequest) (*GetUserSessionsResponse, error)
	DeleteSession(context.Context, *DeleteSessionRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedSessionManagementServiceServer()
}

// UnimplementedSessionManagementServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSessionManagementServiceServer struct {
}

func (UnimplementedSessionManagementServiceServer) GetUserSessions(context.Context, *GetUserSessionsRequest) (*GetUserSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserSessions not implemented")
}
func (UnimplementedSessionManagementServiceServer) DeleteSession(context.Context, *DeleteSessionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSession not implemented")
}
func (UnimplementedSessionManagementServiceServer) mustEmbedUnimplementedSessionManagementServiceServer() {
}

// UnsafeSessionManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionManagementServiceServer will
// result in compilation errors.
type UnsafeSessionManagementServiceServer interface {
	mustEmbedUnimplementedSessionManagementServiceServer()
}

func RegisterSessionManagementServiceServer(s grpc.ServiceRegistrar, srv SessionManagementServiceServer) {
	s.RegisterService(&SessionManagementService_ServiceDesc, srv)
}

func _SessionManagementService_GetUserSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagementServiceServer).GetUserSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManagementService_GetUserSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagementServiceServer).GetUserSessions(ctx, req.(*GetUserSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionManagementService_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionManagementServiceServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionManagementService_DeleteSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionManagementServiceServer).DeleteSession(ctx, req.(*DeleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionManagementService_ServiceDesc is the grpc.ServiceDesc for SessionManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.SessionManagementService",
	HandlerType: (*SessionManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserSessions",
			Handler:    _SessionManagementService_GetUserSessions_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _SessionManagementService_DeleteSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	UserRoleService_GetUserRoles_FullMethodName   = "/auth.UserRoleService/GetUserRoles"
	UserRoleService_AddUserRole_FullMethodName    = "/auth.UserRoleService/AddUserRole"
	UserRoleService_RemoveUserRole_FullMethodName = "/auth.UserRoleService/RemoveUserRole"
)

// UserRoleServiceClient is the client API for UserRoleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// User Role Service
type UserRoleServiceClient interface {
	GetUserRoles(ctx context.Context, in *GetUserRolesRequest, opts ...grpc.CallOption) (*GetUserRolesResponse, error)
	AddUserRole(ctx context.Context, in *AddUserRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveUserRole(ctx context.Context, in *RemoveUserRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userRoleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserRoleServiceClient(cc grpc.ClientConnInterface) UserRoleServiceClient {
	return &userRoleServiceClient{cc}
}

func (c *userRoleServiceClient) GetUserRoles(ctx context.Context, in *GetUserRolesRequest, opts ...grpc.CallOption) (*GetUserRolesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserRolesResponse)
	err := c.cc.Invoke(ctx, UserRoleService_GetUserRoles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRoleServiceClient) AddUserRole(ctx context.Context, in *AddUserRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserRoleService_AddUserRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userRoleServiceClient) RemoveUserRole(ctx context.Context, in *RemoveUserRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserRoleService_RemoveUserRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserRoleServiceServer is the server API for UserRoleService service.
// All implementations must embed UnimplementedUserRoleServiceServer
// for forward compatibility
//
// User Role Service
type UserRoleServiceServer interface {
	GetUserRoles(context.Context, *GetUserRolesRequest) (*GetUserRolesResponse, error)
	AddUserRole(context.Context, *AddUserRoleRequest) (*emptypb.Empty, error)
	RemoveUserRole(context.Context, *RemoveUserRoleRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserRoleServiceServer()
}

// UnimplementedUserRoleServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserRoleServiceServer struct {
}

func (UnimplementedUserRoleServiceServer) GetUserRoles(context.Context, *GetUserRolesRequest) (*GetUserRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserRoles not implemented")
}
func (UnimplementedUserRoleServiceServer) AddUserRole(context.Context, *AddUserRoleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserRole not implemented")
}
func (UnimplementedUserRoleServiceServer) RemoveUserRole(context.Context, *RemoveUserRoleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUserRole not implemented")
}
func (UnimplementedUserRoleServiceServer) mustEmbedUnimplementedUserRoleServiceServer() {}

// UnsafeUserRoleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserRoleServiceServer will
// result in compilation errors.
type UnsafeUserRoleServiceServer interface {
	mustEmbedUnimplementedUserRoleServiceServer()
}

func RegisterUserRoleServiceServer(s grpc.ServiceRegistrar, srv UserRoleServiceServer) {
	s.RegisterService(&UserRoleService_ServiceDesc, srv)
}

func _UserRoleService_GetUserRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRolesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRoleServiceServer).GetUserRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRoleService_GetUserRoles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRoleServiceServer).GetUserRoles(ctx, req.(*GetUserRolesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRoleService_AddUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRoleServiceServer).AddUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRoleService_AddUserRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRoleServiceServer).AddUserRole(ctx, req.(*AddUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserRoleService_RemoveUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRoleServiceServer).RemoveUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRoleService_RemoveUserRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRoleServiceServer).RemoveUserRole(ctx, req.(*RemoveUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserRoleService_ServiceDesc is the grpc.ServiceDesc for UserRoleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserRoleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.UserRoleService",
	HandlerType: (*UserRoleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserRoles",
			Handler:    _UserRoleService_GetUserRoles_Handler,
		},
		{
			MethodName: "AddUserRole",
			Handler:    _UserRoleService_AddUserRole_Handler,
		},
		{
			MethodName: "RemoveUserRole",
			Handler:    _UserRoleService_RemoveUserRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	AvatarService_UpdateUserAvatar_FullMethodName     = "/auth.AvatarService/UpdateUserAvatar"
	AvatarService_GetUserAvatarHistory_FullMethodName = "/auth.AvatarService/GetUserAvatarHistory"
)

// AvatarServiceClient is the client API for AvatarService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Avatar Service
type AvatarServiceClient interface {
	UpdateUserAvatar(ctx context.Context, in *UpdateUserAvatarRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetUserAvatarHistory(ctx context.Context, in *GetUserAvatarHistoryRequest, opts ...grpc.CallOption) (*GetUserAvatarHistoryResponse, error)
}

type avatarServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAvatarServiceClient(cc grpc.ClientConnInterface) AvatarServiceClient {
	return &avatarServiceClient{cc}
}

func (c *avatarServiceClient) UpdateUserAvatar(ctx context.Context, in *UpdateUserAvatarRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AvatarService_UpdateUserAvatar_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *avatarServiceClient) GetUserAvatarHistory(ctx context.Context, in *GetUserAvatarHistoryRequest, opts ...grpc.CallOption) (*GetUserAvatarHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserAvatarHistoryResponse)
	err := c.cc.Invoke(ctx, AvatarService_GetUserAvatarHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AvatarServiceServer is the server API for AvatarService service.
// All implementations must embed UnimplementedAvatarServiceServer
// for forward compatibility
//
// Avatar Service
type AvatarServiceServer interface {
	UpdateUserAvatar(context.Context, *UpdateUserAvatarRequest) (*emptypb.Empty, error)
	GetUserAvatarHistory(context.Context, *GetUserAvatarHistoryRequest) (*GetUserAvatarHistoryResponse, error)
	mustEmbedUnimplementedAvatarServiceServer()
}

// UnimplementedAvatarServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAvatarServiceServer struct {
}

func (UnimplementedAvatarServiceServer) UpdateUserAvatar(context.Context, *UpdateUserAvatarRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserAvatar not implemented")
}
func (UnimplementedAvatarServiceServer) GetUserAvatarHistory(context.Context, *GetUserAvatarHistoryRequest) (*GetUserAvatarHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserAvatarHistory not implemented")
}
func (UnimplementedAvatarServiceServer) mustEmbedUnimplementedAvatarServiceServer() {}

// UnsafeAvatarServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AvatarServiceServer will
// result in compilation errors.
type UnsafeAvatarServiceServer interface {
	mustEmbedUnimplementedAvatarServiceServer()
}

func RegisterAvatarServiceServer(s grpc.ServiceRegistrar, srv AvatarServiceServer) {
	s.RegisterService(&AvatarService_ServiceDesc, srv)
}

func _AvatarService_UpdateUserAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserAvatarRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvatarServiceServer).UpdateUserAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AvatarService_UpdateUserAvatar_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvatarServiceServer).UpdateUserAvatar(ctx, req.(*UpdateUserAvatarRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AvatarService_GetUserAvatarHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserAvatarHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AvatarServiceServer).GetUserAvatarHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AvatarService_GetUserAvatarHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AvatarServiceServer).GetUserAvatarHistory(ctx, req.(*GetUserAvatarHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AvatarService_ServiceDesc is the grpc.ServiceDesc for AvatarService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AvatarService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AvatarService",
	HandlerType: (*AvatarServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateUserAvatar",
			Handler:    _AvatarService_UpdateUserAvatar_Handler,
		},
		{
			MethodName: "GetUserAvatarHistory",
			Handler:    _AvatarService_GetUserAvatarHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	KeyManagementService_UpdateUserKeys_FullMethodName = "/auth.KeyManagementService/UpdateUserKeys"
	KeyManagementService_VerifyUserKey_FullMethodName  = "/auth.KeyManagementService/VerifyUserKey"
)

// KeyManagementServiceClient is the client API for KeyManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Key Management Service
type KeyManagementServiceClient interface {
	UpdateUserKeys(ctx context.Context, in *UpdateUserKeysRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	VerifyUserKey(ctx context.Context, in *VerifyUserKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type keyManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKeyManagementServiceClient(cc grpc.ClientConnInterface) KeyManagementServiceClient {
	return &keyManagementServiceClient{cc}
}

func (c *keyManagementServiceClient) UpdateUserKeys(ctx context.Context, in *UpdateUserKeysRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, KeyManagementService_UpdateUserKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyManagementServiceClient) VerifyUserKey(ctx context.Context, in *VerifyUserKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, KeyManagementService_VerifyUserKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeyManagementServiceServer is the server API for KeyManagementService service.
// All implementations must embed UnimplementedKeyManagementServiceServer
// for forward compatibility
//
// Key Management Service
type KeyManagementServiceServer interface {
	UpdateUserKeys(context.Context, *UpdateUserKeysRequest) (*emptypb.Empty, error)
	VerifyUserKey(context.Context, *VerifyUserKeyRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedKeyManagementServiceServer()
}

// UnimplementedKeyManagementServiceServer must be embedded to have forward compatible implementations.
type UnimplementedKeyManagementServiceServer struct {
}

func (UnimplementedKeyManagementServiceServer) UpdateUserKeys(context.Context, *UpdateUserKeysRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserKeys not implemented")
}
func (UnimplementedKeyManagementServiceServer) VerifyUserKey(context.Context, *VerifyUserKeyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyUserKey not implemented")
}
func (UnimplementedKeyManagementServiceServer) mustEmbedUnimplementedKeyManagementServiceServer() {}

// UnsafeKeyManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeyManagementServiceServer will
// result in compilation errors.
type UnsafeKeyManagementServiceServer interface {
	mustEmbedUnimplementedKeyManagementServiceServer()
}

func RegisterKeyManagementServiceServer(s grpc.ServiceRegistrar, srv KeyManagementServiceServer) {
	s.RegisterService(&KeyManagementService_ServiceDesc, srv)
}

func _KeyManagementService_UpdateUserKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyManagementServiceServer).UpdateUserKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyManagementService_UpdateUserKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyManagementServiceServer).UpdateUserKeys(ctx, req.(*UpdateUserKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyManagementService_VerifyUserKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyUserKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyManagementServiceServer).VerifyUserKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyManagementService_VerifyUserKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyManagementServiceServer).VerifyUserKey(ctx, req.(*VerifyUserKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KeyManagementService_ServiceDesc is the grpc.ServiceDesc for KeyManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeyManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.KeyManagementService",
	HandlerType: (*KeyManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateUserKeys",
			Handler:    _KeyManagementService_UpdateUserKeys_Handler,
		},
		{
			MethodName: "VerifyUserKey",
			Handler:    _KeyManagementService_VerifyUserKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	DeviceManagementService_RevokeDevice_FullMethodName = "/auth.DeviceManagementService/RevokeDevice"
)

// DeviceManagementServiceClient is the client API for DeviceManagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Device Management Service
type DeviceManagementServiceClient interface {
	RevokeDevice(ctx context.Context, in *RevokeDeviceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type deviceManagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeviceManagementServiceClient(cc grpc.ClientConnInterface) DeviceManagementServiceClient {
	return &deviceManagementServiceClient{cc}
}

func (c *deviceManagementServiceClient) RevokeDevice(ctx context.Context, in *RevokeDeviceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DeviceManagementService_RevokeDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeviceManagementServiceServer is the server API for DeviceManagementService service.
// All implementations must embed UnimplementedDeviceManagementServiceServer
// for forward compatibility
//
// Device Management Service
type DeviceManagementServiceServer interface {
	RevokeDevice(context.Context, *RevokeDeviceRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedDeviceManagementServiceServer()
}

// UnimplementedDeviceManagementServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDeviceManagementServiceServer struct {
}

func (UnimplementedDeviceManagementServiceServer) RevokeDevice(context.Context, *RevokeDeviceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeDevice not implemented")
}
func (UnimplementedDeviceManagementServiceServer) mustEmbedUnimplementedDeviceManagementServiceServer() {
}

// UnsafeDeviceManagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeviceManagementServiceServer will
// result in compilation errors.
type UnsafeDeviceManagementServiceServer interface {
	mustEmbedUnimplementedDeviceManagementServiceServer()
}

func RegisterDeviceManagementServiceServer(s grpc.ServiceRegistrar, srv DeviceManagementServiceServer) {
	s.RegisterService(&DeviceManagementService_ServiceDesc, srv)
}

func _DeviceManagementService_RevokeDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceManagementServiceServer).RevokeDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceManagementService_RevokeDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceManagementServiceServer).RevokeDevice(ctx, req.(*RevokeDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DeviceManagementService_ServiceDesc is the grpc.ServiceDesc for DeviceManagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeviceManagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.DeviceManagementService",
	HandlerType: (*DeviceManagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RevokeDevice",
			Handler:    _DeviceManagementService_RevokeDevice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	AccountRecoveryService_InitiateAccountRecovery_FullMethodName = "/auth.AccountRecoveryService/InitiateAccountRecovery"
	AccountRecoveryService_CompleteAccountRecovery_FullMethodName = "/auth.AccountRecoveryService/CompleteAccountRecovery"
)

// AccountRecoveryServiceClient is the client API for AccountRecoveryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Account Recovery Service
type AccountRecoveryServiceClient interface {
	InitiateAccountRecovery(ctx context.Context, in *InitiateAccountRecoveryRequest, opts ...grpc.CallOption) (*InitiateAccountRecoveryResponse, error)
	CompleteAccountRecovery(ctx context.Context, in *CompleteAccountRecoveryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type accountRecoveryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountRecoveryServiceClient(cc grpc.ClientConnInterface) AccountRecoveryServiceClient {
	return &accountRecoveryServiceClient{cc}
}

func (c *accountRecoveryServiceClient) InitiateAccountRecovery(ctx context.Context, in *InitiateAccountRecoveryRequest, opts ...grpc.CallOption) (*InitiateAccountRecoveryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitiateAccountRecoveryResponse)
	err := c.cc.Invoke(ctx, AccountRecoveryService_InitiateAccountRecovery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountRecoveryServiceClient) CompleteAccountRecovery(ctx context.Context, in *CompleteAccountRecoveryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AccountRecoveryService_CompleteAccountRecovery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountRecoveryServiceServer is the server API for AccountRecoveryService service.
// All implementations must embed UnimplementedAccountRecoveryServiceServer
// for forward compatibility
//
// Account Recovery Service
type AccountRecoveryServiceServer interface {
	InitiateAccountRecovery(context.Context, *InitiateAccountRecoveryRequest) (*InitiateAccountRecoveryResponse, error)
	CompleteAccountRecovery(context.Context, *CompleteAccountRecoveryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedAccountRecoveryServiceServer()
}

// UnimplementedAccountRecoveryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAccountRecoveryServiceServer struct {
}

func (UnimplementedAccountRecoveryServiceServer) InitiateAccountRecovery(context.Context, *InitiateAccountRecoveryRequest) (*InitiateAccountRecoveryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateAccountRecovery not implemented")
}
func (UnimplementedAccountRecoveryServiceServer) CompleteAccountRecovery(context.Context, *CompleteAccountRecoveryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteAccountRecovery not implemented")
}
func (UnimplementedAccountRecoveryServiceServer) mustEmbedUnimplementedAccountRecoveryServiceServer() {
}

// UnsafeAccountRecoveryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountRecoveryServiceServer will
// result in compilation errors.
type UnsafeAccountRecoveryServiceServer interface {
	mustEmbedUnimplementedAccountRecoveryServiceServer()
}

func RegisterAccountRecoveryServiceServer(s grpc.ServiceRegistrar, srv AccountRecoveryServiceServer) {
	s.RegisterService(&AccountRecoveryService_ServiceDesc, srv)
}

func _AccountRecoveryService_InitiateAccountRecovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitiateAccountRecoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountRecoveryServiceServer).InitiateAccountRecovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountRecoveryService_InitiateAccountRecovery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountRecoveryServiceServer).InitiateAccountRecovery(ctx, req.(*InitiateAccountRecoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountRecoveryService_CompleteAccountRecovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteAccountRecoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountRecoveryServiceServer).CompleteAccountRecovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccountRecoveryService_CompleteAccountRecovery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountRecoveryServiceServer).CompleteAccountRecovery(ctx, req.(*CompleteAccountRecoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AccountRecoveryService_ServiceDesc is the grpc.ServiceDesc for AccountRecoveryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccountRecoveryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AccountRecoveryService",
	HandlerType: (*AccountRecoveryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitiateAccountRecovery",
			Handler:    _AccountRecoveryService_InitiateAccountRecovery_Handler,
		},
		{
			MethodName: "CompleteAccountRecovery",
			Handler:    _AccountRecoveryService_CompleteAccountRecovery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/speech.proto",
}

const (
	UserStatusService_StreamUserStatus_FullMethodName = "/auth.UserStatusService/StreamUserStatus"
)

// UserStatusServiceClient is the client API for UserStatusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// User Status Service
type UserStatusServiceClient interface {
	StreamUserStatus(ctx context.Context, opts ...grpc.CallOption) (UserStatusService_StreamUserStatusClient, error)
}

type userStatusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserStatusServiceClient(cc grpc.ClientConnInterface) UserStatusServiceClient {
	return &userStatusServiceClient{cc}
}

func (c *userStatusServiceClient) StreamUserStatus(ctx context.Context, opts ...grpc.CallOption) (UserStatusService_StreamUserStatusClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &UserStatusService_ServiceDesc.Streams[0], UserStatusService_StreamUserStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &userStatusServiceStreamUserStatusClient{ClientStream: stream}
	return x, nil
}

type UserStatusService_StreamUserStatusClient interface {
	Send(*UserStatusUpdate) error
	Recv() (*UserStatusUpdate, error)
	grpc.ClientStream
}

type userStatusServiceStreamUserStatusClient struct {
	grpc.ClientStream
}

func (x *userStatusServiceStreamUserStatusClient) Send(m *UserStatusUpdate) error {
	return x.ClientStream.SendMsg(m)
}

func (x *userStatusServiceStreamUserStatusClient) Recv() (*UserStatusUpdate, error) {
	m := new(UserStatusUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UserStatusServiceServer is the server API for UserStatusService service.
// All implementations must embed UnimplementedUserStatusServiceServer
// for forward compatibility
//
// User Status Service
type UserStatusServiceServer interface {
	StreamUserStatus(UserStatusService_StreamUserStatusServer) error
	mustEmbedUnimplementedUserStatusServiceServer()
}

// UnimplementedUserStatusServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserStatusServiceServer struct {
}

func (UnimplementedUserStatusServiceServer) StreamUserStatus(UserStatusService_StreamUserStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamUserStatus not implemented")
}
func (UnimplementedUserStatusServiceServer) mustEmbedUnimplementedUserStatusServiceServer() {}

// UnsafeUserStatusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserStatusServiceServer will
// result in compilation errors.
type UnsafeUserStatusServiceServer interface {
	mustEmbedUnimplementedUserStatusServiceServer()
}

func RegisterUserStatusServiceServer(s grpc.ServiceRegistrar, srv UserStatusServiceServer) {
	s.RegisterService(&UserStatusService_ServiceDesc, srv)
}

func _UserStatusService_StreamUserStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UserStatusServiceServer).StreamUserStatus(&userStatusServiceStreamUserStatusServer{ServerStream: stream})
}

type UserStatusService_StreamUserStatusServer interface {
	Send(*UserStatusUpdate) error
	Recv() (*UserStatusUpdate, error)
	grpc.ServerStream
}

type userStatusServiceStreamUserStatusServer struct {
	grpc.ServerStream
}

func (x *userStatusServiceStreamUserStatusServer) Send(m *UserStatusUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func (x *userStatusServiceStreamUserStatusServer) Recv() (*UserStatusUpdate, error) {
	m := new(UserStatusUpdate)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UserStatusService_ServiceDesc is the grpc.ServiceDesc for UserStatusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserStatusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.UserStatusService",
	HandlerType: (*UserStatusServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamUserStatus",
			Handler:       _UserStatusService_StreamUserStatus_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "internal/proto/speech.proto",
}

const (
	ChatService_InitiateChat_FullMethodName                = "/auth.ChatService/InitiateChat"
	ChatService_SendMessage_FullMethodName                 = "/auth.ChatService/SendMessage"
	ChatService_ReceiveMessages_FullMethodName             = "/auth.ChatService/ReceiveMessages"
	ChatService_UpdateMessageStatus_FullMethodName         = "/auth.ChatService/UpdateMessageStatus"
	ChatService_ReplyToMessage_FullMethodName              = "/auth.ChatService/ReplyToMessage"
	ChatService_ForwardMessage_FullMethodName              = "/auth.ChatService/ForwardMessage"
	ChatService_DeleteMessage_FullMethodName               = "/auth.ChatService/DeleteMessage"
	ChatService_RequestMissingMessages_FullMethodName      = "/auth.ChatService/RequestMissingMessages"
	ChatService_CreatePublicGroupChat_FullMethodName       = "/auth.ChatService/CreatePublicGroupChat"
	ChatService_CreatePrivateGroupChat_FullMethodName      = "/auth.ChatService/CreatePrivateGroupChat"
	ChatService_JoinPublicGroupChat_FullMethodName         = "/auth.ChatService/JoinPublicGroupChat"
	ChatService_CreateChatInvitation_FullMethodName        = "/auth.ChatService/CreateChatInvitation"
	ChatService_JoinPrivateGroupChat_FullMethodName        = "/auth.ChatService/JoinPrivateGroupChat"
	ChatService_UpdateGroupInfo_FullMethodName             = "/auth.ChatService/UpdateGroupInfo"
	ChatService_AddGroupMember_FullMethodName              = "/auth.ChatService/AddGroupMember"
	ChatService_RemoveGroupMember_FullMethodName           = "/auth.ChatService/RemoveGroupMember"
	ChatService_UpdateGroupKey_FullMethodName              = "/auth.ChatService/UpdateGroupKey"
	ChatService_SendGroupMessage_FullMethodName            = "/auth.ChatService/SendGroupMessage"
	ChatService_RequestMissingGroupMessages_FullMethodName = "/auth.ChatService/RequestMissingGroupMessages"
	ChatService_BanUser_FullMethodName                     = "/auth.ChatService/BanUser"
	ChatService_UnbanUser_FullMethodName                   = "/auth.ChatService/UnbanUser"
	ChatService_UpdateUserRole_FullMethodName              = "/auth.ChatService/UpdateUserRole"
	ChatService_CreateCustomRole_FullMethodName            = "/auth.ChatService/CreateCustomRole"
	ChatService_CreateInviteLink_FullMethodName            = "/auth.ChatService/CreateInviteLink"
	ChatService_PinMessage_FullMethodName                  = "/auth.ChatService/PinMessage"
	ChatService_UnpinMessage_FullMethodName                = "/auth.ChatService/UnpinMessage"
	ChatService_CreateRoom_FullMethodName                  = "/auth.ChatService/CreateRoom"
	ChatService_UpdateRoom_FullMethodName                  = "/auth.ChatService/UpdateRoom"
	ChatService_DeleteRoom_FullMethodName                  = "/auth.ChatService/DeleteRoom"
	ChatService_StreamUserStatus_FullMethodName            = "/auth.ChatService/StreamUserStatus"
	ChatService_TransferChatHistory_FullMethodName         = "/auth.ChatService/TransferChatHistory"
)

// ChatServiceClient is the client API for ChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Updated ChatService
type ChatServiceClient interface {
	// Direct messaging
	InitiateChat(ctx context.Context, in *InitiateChatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
	ReceiveMessages(ctx context.Context, in *ReceiveMessagesRequest, opts ...grpc.CallOption) (ChatService_ReceiveMessagesClient, error)
	UpdateMessageStatus(ctx context.Context, in *UpdateMessageStatusRequest, opts ...grpc.CallOption) (*UpdateMessageStatusResponse, error)
	ReplyToMessage(ctx context.Context, in *ReplyToMessageRequest, opts ...grpc.CallOption) (*ReplyToMessageResponse, error)
	ForwardMessage(ctx context.Context, in *ForwardMessageRequest, opts ...grpc.CallOption) (*ForwardMessageResponse, error)
	DeleteMessage(ctx context.Context, in *DeleteMessageRequest, opts ...grpc.CallOption) (*DeleteMessageResponse, error)
	RequestMissingMessages(ctx context.Context, in *RequestMissingMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error)
	// Group chat
	CreatePublicGroupChat(ctx context.Context, in *CreatePublicGroupChatRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error)
	CreatePrivateGroupChat(ctx context.Context, in *CreatePrivateGroupChatRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error)
	JoinPublicGroupChat(ctx context.Context, in *JoinPublicGroupChatRequest, opts ...grpc.CallOption) (*JoinGroupResponse, error)
	CreateChatInvitation(ctx context.Context, in *CreateChatInvitationRequest, opts ...grpc.CallOption) (*CreateChatInvitationResponse, error)
	JoinPrivateGroupChat(ctx context.Context, in *JoinPrivateGroupChatRequest, opts ...grpc.CallOption) (*JoinGroupResponse, error)
	UpdateGroupInfo(ctx context.Context, in *UpdateGroupInfoRequest, opts ...grpc.CallOption) (*UpdateGroupInfoResponse, error)
	AddGroupMember(ctx context.Context, in *AddGroupMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveGroupMember(ctx context.Context, in *RemoveGroupMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateGroupKey(ctx context.Context, in *UpdateGroupKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SendGroupMessage(ctx context.Context, in *GroupMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RequestMissingGroupMessages(ctx context.Context, in *RequestMissingGroupMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error)
	// User management in chats
	BanUser(ctx context.Context, in *BanUserRequest, opts ...grpc.CallOption) (*BanUserResponse, error)
	UnbanUser(ctx context.Context, in *UnbanUserRequest, opts ...grpc.CallOption) (*UnbanUserResponse, error)
	UpdateUserRole(ctx context.Context, in *UpdateUserRoleRequest, opts ...grpc.CallOption) (*UpdateUserRoleResponse, error)
	CreateCustomRole(ctx context.Context, in *CreateCustomRoleRequest, opts ...grpc.CallOption) (*CreateCustomRoleResponse, error)
	// Chat features
	CreateInviteLink(ctx context.Context, in *CreateInviteLinkRequest, opts ...grpc.CallOption) (*CreateInviteLinkResponse, error)
	PinMessage(ctx context.Context, in *PinMessageRequest, opts ...grpc.CallOption) (*PinMessageResponse, error)
	UnpinMessage(ctx context.Context, in *UnpinMessageRequest, opts ...grpc.CallOption) (*UnpinMessageResponse, error)
	// Room management
	CreateRoom(ctx context.Context, in *CreateRoomRequest, opts ...grpc.CallOption) (*CreateRoomResponse, error)
	UpdateRoom(ctx context.Context, in *UpdateRoomRequest, opts ...grpc.CallOption) (*UpdateRoomResponse, error)
	DeleteRoom(ctx context.Context, in *DeleteRoomRequest, opts ...grpc.CallOption) (*DeleteRoomResponse, error)
	// User status
	StreamUserStatus(ctx context.Context, opts ...grpc.CallOption) (ChatService_StreamUserStatusClient, error)
	// Chat history
	TransferChatHistory(ctx context.Context, in *TransferChatHistoryRequest, opts ...grpc.CallOption) (*TransferChatHistoryResponse, error)
}

type chatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatServiceClient(cc grpc.ClientConnInterface) ChatServiceClient {
	return &chatServiceClient{cc}
}

func (c *chatServiceClient) InitiateChat(ctx context.Context, in *InitiateChatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChatService_InitiateChat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMessageResponse)
	err := c.cc.Invoke(ctx, ChatService_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) ReceiveMessages(ctx context.Context, in *ReceiveMessagesRequest, opts ...grpc.CallOption) (ChatService_ReceiveMessagesClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[0], ChatService_ReceiveMessages_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &chatServiceReceiveMessagesClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChatService_ReceiveMessagesClient interface {
	Recv() (*EncryptedMessage, error)
	grpc.ClientStream
}

type chatServiceReceiveMessagesClient struct {
	grpc.ClientStream
}

func (x *chatServiceReceiveMessagesClient) Recv() (*EncryptedMessage, error) {
	m := new(EncryptedMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chatServiceClient) UpdateMessageStatus(ctx context.Context, in *UpdateMessageStatusRequest, opts ...grpc.CallOption) (*UpdateMessageStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateMessageStatusResponse)
	err := c.cc.Invoke(ctx, ChatService_UpdateMessageStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) ReplyToMessage(ctx context.Context, in *ReplyToMessageRequest, opts ...grpc.CallOption) (*ReplyToMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplyToMessageResponse)
	err := c.cc.Invoke(ctx, ChatService_ReplyToMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) ForwardMessage(ctx context.Context, in *ForwardMessageRequest, opts ...grpc.CallOption) (*ForwardMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ForwardMessageResponse)
	err := c.cc.Invoke(ctx, ChatService_ForwardMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) DeleteMessage(ctx context.Context, in *DeleteMessageRequest, opts ...grpc.CallOption) (*DeleteMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMessageResponse)
	err := c.cc.Invoke(ctx, ChatService_DeleteMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) RequestMissingMessages(ctx context.Context, in *RequestMissingMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessagesResponse)
	err := c.cc.Invoke(ctx, ChatService_RequestMissingMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) CreatePublicGroupChat(ctx context.Context, in *CreatePublicGroupChatRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateGroupResponse)
	err := c.cc.Invoke(ctx, ChatService_CreatePublicGroupChat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) CreatePrivateGroupChat(ctx context.Context, in *CreatePrivateGroupChatRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateGroupResponse)
	err := c.cc.Invoke(ctx, ChatService_CreatePrivateGroupChat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) JoinPublicGroupChat(ctx context.Context, in *JoinPublicGroupChatRequest, opts ...grpc.CallOption) (*JoinGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinGroupResponse)
	err := c.cc.Invoke(ctx, ChatService_JoinPublicGroupChat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) CreateChatInvitation(ctx context.Context, in *CreateChatInvitationRequest, opts ...grpc.CallOption) (*CreateChatInvitationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateChatInvitationResponse)
	err := c.cc.Invoke(ctx, ChatService_CreateChatInvitation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) JoinPrivateGroupChat(ctx context.Context, in *JoinPrivateGroupChatRequest, opts ...grpc.CallOption) (*JoinGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinGroupResponse)
	err := c.cc.Invoke(ctx, ChatService_JoinPrivateGroupChat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) UpdateGroupInfo(ctx context.Context, in *UpdateGroupInfoRequest, opts ...grpc.CallOption) (*UpdateGroupInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGroupInfoResponse)
	err := c.cc.Invoke(ctx, ChatService_UpdateGroupInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) AddGroupMember(ctx context.Context, in *AddGroupMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChatService_AddGroupMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) RemoveGroupMember(ctx context.Context, in *RemoveGroupMemberRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChatService_RemoveGroupMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) UpdateGroupKey(ctx context.Context, in *UpdateGroupKeyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChatService_UpdateGroupKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) SendGroupMessage(ctx context.Context, in *GroupMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChatService_SendGroupMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) RequestMissingGroupMessages(ctx context.Context, in *RequestMissingGroupMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessagesResponse)
	err := c.cc.Invoke(ctx, ChatService_RequestMissingGroupMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) BanUser(ctx context.Context, in *BanUserRequest, opts ...grpc.CallOption) (*BanUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BanUserResponse)
	err := c.cc.Invoke(ctx, ChatService_BanUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) UnbanUser(ctx context.Context, in *UnbanUserRequest, opts ...grpc.CallOption) (*UnbanUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnbanUserResponse)
	err := c.cc.Invoke(ctx, ChatService_UnbanUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) UpdateUserRole(ctx context.Context, in *UpdateUserRoleRequest, opts ...grpc.CallOption) (*UpdateUserRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserRoleResponse)
	err := c.cc.Invoke(ctx, ChatService_UpdateUserRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) CreateCustomRole(ctx context.Context, in *CreateCustomRoleRequest, opts ...grpc.CallOption) (*CreateCustomRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCustomRoleResponse)
	err := c.cc.Invoke(ctx, ChatService_CreateCustomRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) CreateInviteLink(ctx context.Context, in *CreateInviteLinkRequest, opts ...grpc.CallOption) (*CreateInviteLinkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateInviteLinkResponse)
	err := c.cc.Invoke(ctx, ChatService_CreateInviteLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) PinMessage(ctx context.Context, in *PinMessageRequest, opts ...grpc.CallOption) (*PinMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PinMessageResponse)
	err := c.cc.Invoke(ctx, ChatService_PinMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) UnpinMessage(ctx context.Context, in *UnpinMessageRequest, opts ...grpc.CallOption) (*UnpinMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnpinMessageResponse)
	err := c.cc.Invoke(ctx, ChatService_UnpinMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) CreateRoom(ctx context.Context, in *CreateRoomRequest, opts ...grpc.CallOption) (*CreateRoomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateRoomResponse)
	err := c.cc.Invoke(ctx, ChatService_CreateRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) UpdateRoom(ctx context.Context, in *UpdateRoomRequest, opts ...grpc.CallOption) (*UpdateRoomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateRoomResponse)
	err := c.cc.Invoke(ctx, ChatService_UpdateRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) DeleteRoom(ctx context.Context, in *DeleteRoomRequest, opts ...grpc.CallOption) (*DeleteRoomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRoomResponse)
	err := c.cc.Invoke(ctx, ChatService_DeleteRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) StreamUserStatus(ctx context.Context, opts ...grpc.CallOption) (ChatService_StreamUserStatusClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[1], ChatService_StreamUserStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &chatServiceStreamUserStatusClient{ClientStream: stream}
	return x, nil
}

type ChatService_StreamUserStatusClient interface {
	Send(*UserStatusUpdate) error
	Recv() (*UserStatusUpdate, error)
	grpc.ClientStream
}

type chatServiceStreamUserStatusClient struct {
	grpc.ClientStream
}

func (x *chatServiceStreamUserStatusClient) Send(m *UserStatusUpdate) error {
	return x.ClientStream.SendMsg(m)
}

func (x *chatServiceStreamUserStatusClient) Recv() (*UserStatusUpdate, error) {
	m := new(UserStatusUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chatServiceClient) TransferChatHistory(ctx context.Context, in *TransferChatHistoryRequest, opts ...grpc.CallOption) (*TransferChatHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferChatHistoryResponse)
	err := c.cc.Invoke(ctx, ChatService_TransferChatHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChatServiceServer is the server API for ChatService service.
// All implementations must embed UnimplementedChatServiceServer
// for forward compatibility
//
// Updated ChatService
type ChatServiceServer interface {
	// Direct messaging
	InitiateChat(context.Context, *InitiateChatRequest) (*emptypb.Empty, error)
	SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error)
	ReceiveMessages(*ReceiveMessagesRequest, ChatService_ReceiveMessagesServer) error
	UpdateMessageStatus(context.Context, *UpdateMessageStatusRequest) (*UpdateMessageStatusResponse, error)
	ReplyToMessage(context.Context, *ReplyToMessageRequest) (*ReplyToMessageResponse, error)
	ForwardMessage(context.Context, *ForwardMessageRequest) (*ForwardMessageResponse, error)
	DeleteMessage(context.Context, *DeleteMessageRequest) (*DeleteMessageResponse, error)
	RequestMissingMessages(context.Context, *RequestMissingMessagesRequest) (*GetMessagesResponse, error)
	// Group chat
	CreatePublicGroupChat(context.Context, *CreatePublicGroupChatRequest) (*CreateGroupResponse, error)
	CreatePrivateGroupChat(context.Context, *CreatePrivateGroupChatRequest) (*CreateGroupResponse, error)
	JoinPublicGroupChat(context.Context, *JoinPublicGroupChatRequest) (*JoinGroupResponse, error)
	CreateChatInvitation(context.Context, *CreateChatInvitationRequest) (*CreateChatInvitationResponse, error)
	JoinPrivateGroupChat(context.Context, *JoinPrivateGroupChatRequest) (*JoinGroupResponse, error)
	UpdateGroupInfo(context.Context, *UpdateGroupInfoRequest) (*UpdateGroupInfoResponse, error)
	AddGroupMember(context.Context, *AddGroupMemberRequest) (*emptypb.Empty, error)
	RemoveGroupMember(context.Context, *RemoveGroupMemberRequest) (*emptypb.Empty, error)
	UpdateGroupKey(context.Context, *UpdateGroupKeyRequest) (*emptypb.Empty, error)
	SendGroupMessage(context.Context, *GroupMessageRequest) (*emptypb.Empty, error)
	RequestMissingGroupMessages(context.Context, *RequestMissingGroupMessagesRequest) (*GetMessagesResponse, error)
	// User management in chats
	BanUser(context.Context, *BanUserRequest) (*BanUserResponse, error)
	UnbanUser(context.Context, *UnbanUserRequest) (*UnbanUserResponse, error)
	UpdateUserRole(context.Context, *UpdateUserRoleRequest) (*UpdateUserRoleResponse, error)
	CreateCustomRole(context.Context, *CreateCustomRoleRequest) (*CreateCustomRoleResponse, error)
	// Chat features
	CreateInviteLink(context.Context, *CreateInviteLinkRequest) (*CreateInviteLinkResponse, error)
	PinMessage(context.Context, *PinMessageRequest) (*PinMessageResponse, error)
	UnpinMessage(context.Context, *UnpinMessageRequest) (*UnpinMessageResponse, error)
	// Room management
	CreateRoom(context.Context, *CreateRoomRequest) (*CreateRoomResponse, error)
	UpdateRoom(context.Context, *UpdateRoomRequest) (*UpdateRoomResponse, error)
	DeleteRoom(context.Context, *DeleteRoomRequest) (*DeleteRoomResponse, error)
	// User status
	StreamUserStatus(ChatService_StreamUserStatusServer) error
	// Chat history
	TransferChatHistory(context.Context, *TransferChatHistoryRequest) (*TransferChatHistoryResponse, error)
	mustEmbedUnimplementedChatServiceServer()
}

// UnimplementedChatServiceServer must be embedded to have forward compatible implementations.
type UnimplementedChatServiceServer struct {
}

func (UnimplementedChatServiceServer) InitiateChat(context.Context, *InitiateChatRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateChat not implemented")
}
func (UnimplementedChatServiceServer) SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedChatServiceServer) ReceiveMessages(*ReceiveMessagesRequest, ChatService_ReceiveMessagesServer) error {
	return status.Errorf(codes.Unimplemented, "method ReceiveMessages not implemented")
}
func (UnimplementedChatServiceServer) UpdateMessageStatus(context.Context, *UpdateMessageStatusRequest) (*UpdateMessageStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMessageStatus not implemented")
}
func (UnimplementedChatServiceServer) ReplyToMessage(context.Context, *ReplyToMessageRequest) (*ReplyToMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplyToMessage not implemented")
}
func (UnimplementedChatServiceServer) ForwardMessage(context.Context, *ForwardMessageRequest) (*ForwardMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForwardMessage not implemented")
}
func (UnimplementedChatServiceServer) DeleteMessage(context.Context, *DeleteMessageRequest) (*DeleteMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMessage not implemented")
}
func (UnimplementedChatServiceServer) RequestMissingMessages(context.Context, *RequestMissingMessagesRequest) (*GetMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestMissingMessages not implemented")
}
func (UnimplementedChatServiceServer) CreatePublicGroupChat(context.Context, *CreatePublicGroupChatRequest) (*CreateGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePublicGroupChat not implemented")
}
func (UnimplementedChatServiceServer) CreatePrivateGroupChat(context.Context, *CreatePrivateGroupChatRequest) (*CreateGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePrivateGroupChat not implemented")
}
func (UnimplementedChatServiceServer) JoinPublicGroupChat(context.Context, *JoinPublicGroupChatRequest) (*JoinGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinPublicGroupChat not implemented")
}
func (UnimplementedChatServiceServer) CreateChatInvitation(context.Context, *CreateChatInvitationRequest) (*CreateChatInvitationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChatInvitation not implemented")
}
func (UnimplementedChatServiceServer) JoinPrivateGroupChat(context.Context, *JoinPrivateGroupChatRequest) (*JoinGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinPrivateGroupChat not implemented")
}
func (UnimplementedChatServiceServer) UpdateGroupInfo(context.Context, *UpdateGroupInfoRequest) (*UpdateGroupInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroupInfo not implemented")
}
func (UnimplementedChatServiceServer) AddGroupMember(context.Context, *AddGroupMemberRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGroupMember not implemented")
}
func (UnimplementedChatServiceServer) RemoveGroupMember(context.Context, *RemoveGroupMemberRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveGroupMember not implemented")
}
func (UnimplementedChatServiceServer) UpdateGroupKey(context.Context, *UpdateGroupKeyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroupKey not implemented")
}
func (UnimplementedChatServiceServer) SendGroupMessage(context.Context, *GroupMessageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendGroupMessage not implemented")
}
func (UnimplementedChatServiceServer) RequestMissingGroupMessages(context.Context, *RequestMissingGroupMessagesRequest) (*GetMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestMissingGroupMessages not implemented")
}
func (UnimplementedChatServiceServer) BanUser(context.Context, *BanUserRequest) (*BanUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BanUser not implemented")
}
func (UnimplementedChatServiceServer) UnbanUser(context.Context, *UnbanUserRequest) (*UnbanUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbanUser not implemented")
}
func (UnimplementedChatServiceServer) UpdateUserRole(context.Context, *UpdateUserRoleRequest) (*UpdateUserRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserRole not implemented")
}
func (UnimplementedChatServiceServer) CreateCustomRole(context.Context, *CreateCustomRoleRequest) (*CreateCustomRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCustomRole not implemented")
}
func (UnimplementedChatServiceServer) CreateInviteLink(context.Context, *CreateInviteLinkRequest) (*CreateInviteLinkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInviteLink not implemented")
}
func (UnimplementedChatServiceServer) PinMessage(context.Context, *PinMessageRequest) (*PinMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PinMessage not implemented")
}
func (UnimplementedChatServiceServer) UnpinMessage(context.Context, *UnpinMessageRequest) (*UnpinMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnpinMessage not implemented")
}
func (UnimplementedChatServiceServer) CreateRoom(context.Context, *CreateRoomRequest) (*CreateRoomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRoom not implemented")
}
func (UnimplementedChatServiceServer) UpdateRoom(context.Context, *UpdateRoomRequest) (*UpdateRoomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRoom not implemented")
}
func (UnimplementedChatServiceServer) DeleteRoom(context.Context, *DeleteRoomRequest) (*DeleteRoomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoom not implemented")
}
func (UnimplementedChatServiceServer) StreamUserStatus(ChatService_StreamUserStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamUserStatus not implemented")
}
func (UnimplementedChatServiceServer) TransferChatHistory(context.Context, *TransferChatHistoryRequest) (*TransferChatHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferChatHistory not implemented")
}
func (UnimplementedChatServiceServer) mustEmbedUnimplementedChatServiceServer() {}

// UnsafeChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatServiceServer will
// result in compilation errors.
type UnsafeChatServiceServer interface {
	mustEmbedUnimplementedChatServiceServer()
}

func RegisterChatServiceServer(s grpc.ServiceRegistrar, srv ChatServiceServer) {
	s.RegisterService(&ChatService_ServiceDesc, srv)
}

func _ChatService_InitiateChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitiateChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).InitiateChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_InitiateChat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).InitiateChat(ctx, req.(*InitiateChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).SendMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_ReceiveMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReceiveMessagesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).ReceiveMessages(m, &chatServiceReceiveMessagesServer{ServerStream: stream})
}

type ChatService_ReceiveMessagesServer interface {
	Send(*EncryptedMessage) error
	grpc.ServerStream
}

type chatServiceReceiveMessagesServer struct {
	grpc.ServerStream
}

func (x *chatServiceReceiveMessagesServer) Send(m *EncryptedMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _ChatService_UpdateMessageStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMessageStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).UpdateMessageStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_UpdateMessageStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).UpdateMessageStatus(ctx, req.(*UpdateMessageStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_ReplyToMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplyToMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).ReplyToMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_ReplyToMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).ReplyToMessage(ctx, req.(*ReplyToMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_ForwardMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForwardMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).ForwardMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_ForwardMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).ForwardMessage(ctx, req.(*ForwardMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_DeleteMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).DeleteMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_DeleteMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).DeleteMessage(ctx, req.(*DeleteMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_RequestMissingMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestMissingMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).RequestMissingMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_RequestMissingMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).RequestMissingMessages(ctx, req.(*RequestMissingMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_CreatePublicGroupChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePublicGroupChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).CreatePublicGroupChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_CreatePublicGroupChat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).CreatePublicGroupChat(ctx, req.(*CreatePublicGroupChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_CreatePrivateGroupChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePrivateGroupChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).CreatePrivateGroupChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_CreatePrivateGroupChat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).CreatePrivateGroupChat(ctx, req.(*CreatePrivateGroupChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_JoinPublicGroupChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinPublicGroupChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).JoinPublicGroupChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_JoinPublicGroupChat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).JoinPublicGroupChat(ctx, req.(*JoinPublicGroupChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_CreateChatInvitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateChatInvitationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).CreateChatInvitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_CreateChatInvitation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).CreateChatInvitation(ctx, req.(*CreateChatInvitationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_JoinPrivateGroupChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinPrivateGroupChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).JoinPrivateGroupChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_JoinPrivateGroupChat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).JoinPrivateGroupChat(ctx, req.(*JoinPrivateGroupChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_UpdateGroupInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroupInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).UpdateGroupInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_UpdateGroupInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).UpdateGroupInfo(ctx, req.(*UpdateGroupInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_AddGroupMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddGroupMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).AddGroupMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_AddGroupMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).AddGroupMember(ctx, req.(*AddGroupMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_RemoveGroupMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveGroupMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).RemoveGroupMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_RemoveGroupMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).RemoveGroupMember(ctx, req.(*RemoveGroupMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_UpdateGroupKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroupKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).UpdateGroupKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_UpdateGroupKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).UpdateGroupKey(ctx, req.(*UpdateGroupKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_SendGroupMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).SendGroupMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_SendGroupMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).SendGroupMessage(ctx, req.(*GroupMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_RequestMissingGroupMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestMissingGroupMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).RequestMissingGroupMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_RequestMissingGroupMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).RequestMissingGroupMessages(ctx, req.(*RequestMissingGroupMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_BanUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BanUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).BanUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_BanUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).BanUser(ctx, req.(*BanUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_UnbanUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbanUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).UnbanUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_UnbanUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).UnbanUser(ctx, req.(*UnbanUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_UpdateUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).UpdateUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_UpdateUserRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).UpdateUserRole(ctx, req.(*UpdateUserRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_CreateCustomRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCustomRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).CreateCustomRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_CreateCustomRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).CreateCustomRole(ctx, req.(*CreateCustomRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_CreateInviteLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInviteLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).CreateInviteLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_CreateInviteLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).CreateInviteLink(ctx, req.(*CreateInviteLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_PinMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PinMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).PinMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_PinMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).PinMessage(ctx, req.(*PinMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_UnpinMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnpinMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).UnpinMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_UnpinMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).UnpinMessage(ctx, req.(*UnpinMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_CreateRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).CreateRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_CreateRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).CreateRoom(ctx, req.(*CreateRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_UpdateRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).UpdateRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_UpdateRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).UpdateRoom(ctx, req.(*UpdateRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_DeleteRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).DeleteRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_DeleteRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).DeleteRoom(ctx, req.(*DeleteRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_StreamUserStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChatServiceServer).StreamUserStatus(&chatServiceStreamUserStatusServer{ServerStream: stream})
}

type ChatService_StreamUserStatusServer interface {
	Send(*UserStatusUpdate) error
	Recv() (*UserStatusUpdate, error)
	grpc.ServerStream
}

type chatServiceStreamUserStatusServer struct {
	grpc.ServerStream
}

func (x *chatServiceStreamUserStatusServer) Send(m *UserStatusUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func (x *chatServiceStreamUserStatusServer) Recv() (*UserStatusUpdate, error) {
	m := new(UserStatusUpdate)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ChatService_TransferChatHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferChatHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).TransferChatHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_TransferChatHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).TransferChatHistory(ctx, req.(*TransferChatHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChatService_ServiceDesc is the grpc.ServiceDesc for ChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.ChatService",
	HandlerType: (*ChatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitiateChat",
			Handler:    _ChatService_InitiateChat_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _ChatService_SendMessage_Handler,
		},
		{
			MethodName: "UpdateMessageStatus",
			Handler:    _ChatService_UpdateMessageStatus_Handler,
		},
		{
			MethodName: "ReplyToMessage",
			Handler:    _ChatService_ReplyToMessage_Handler,
		},
		{
			MethodName: "ForwardMessage",
			Handler:    _ChatService_ForwardMessage_Handler,
		},
		{
			MethodName: "DeleteMessage",
			Handler:    _ChatService_DeleteMessage_Handler,
		},
		{
			MethodName: "RequestMissingMessages",
			Handler:    _ChatService_RequestMissingMessages_Handler,
		},
		{
			MethodName: "CreatePublicGroupChat",
			Handler:    _ChatService_CreatePublicGroupChat_Handler,
		},
		{
			MethodName: "CreatePrivateGroupChat",
			Handler:    _ChatService_CreatePrivateGroupChat_Handler,
		},
		{
			MethodName: "JoinPublicGroupChat",
			Handler:    _ChatService_JoinPublicGroupChat_Handler,
		},
		{
			MethodName: "CreateChatInvitation",
			Handler:    _ChatService_CreateChatInvitation_Handler,
		},
		{
			MethodName: "JoinPrivateGroupChat",
			Handler:    _ChatService_JoinPrivateGroupChat_Handler,
		},
		{
			MethodName: "UpdateGroupInfo",
			Handler:    _ChatService_UpdateGroupInfo_Handler,
		},
		{
			MethodName: "AddGroupMember",
			Handler:    _ChatService_AddGroupMember_Handler,
		},
		{
			MethodName: "RemoveGroupMember",
			Handler:    _ChatService_RemoveGroupMember_Handler,
		},
		{
			MethodName: "UpdateGroupKey",
			Handler:    _ChatService_UpdateGroupKey_Handler,
		},
		{
			MethodName: "SendGroupMessage",
			Handler:    _ChatService_SendGroupMessage_Handler,
		},
		{
			MethodName: "RequestMissingGroupMessages",
			Handler:    _ChatService_RequestMissingGroupMessages_Handler,
		},
		{
			MethodName: "BanUser",
			Handler:    _ChatService_BanUser_Handler,
		},
		{
			MethodName: "UnbanUser",
			Handler:    _ChatService_UnbanUser_Handler,
		},
		{
			MethodName: "UpdateUserRole",
			Handler:    _ChatService_UpdateUserRole_Handler,
		},
		{
			MethodName: "CreateCustomRole",
			Handler:    _ChatService_CreateCustomRole_Handler,
		},
		{
			MethodName: "CreateInviteLink",
			Handler:    _ChatService_CreateInviteLink_Handler,
		},
		{
			MethodName: "PinMessage",
			Handler:    _ChatService_PinMessage_Handler,
		},
		{
			MethodName: "UnpinMessage",
			Handler:    _ChatService_UnpinMessage_Handler,
		},
		{
			MethodName: "CreateRoom",
			Handler:    _ChatService_CreateRoom_Handler,
		},
		{
			MethodName: "UpdateRoom",
			Handler:    _ChatService_UpdateRoom_Handler,
		},
		{
			MethodName: "DeleteRoom",
			Handler:    _ChatService_DeleteRoom_Handler,
		},
		{
			MethodName: "TransferChatHistory",
			Handler:    _ChatService_TransferChatHistory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReceiveMessages",
			Handler:       _ChatService_ReceiveMessages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamUserStatus",
			Handler:       _ChatService_StreamUserStatus_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "internal/proto/speech.proto",
}
